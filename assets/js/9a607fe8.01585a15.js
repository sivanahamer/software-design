"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8872],{3905:(e,a,n)=>{n.d(a,{Zo:()=>d,kt:()=>g});var t=n(7294);function o(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){o(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,o=function(e,a){if(null==e)return{};var n,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(o[n]=e[n]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=t.createContext({}),c=function(e){var a=t.useContext(i),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},d=function(e){var a=c(e.components);return t.createElement(i.Provider,{value:a},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,g=p["".concat(i,".").concat(u)]||p[u]||m[u]||r;return n?t.createElement(g,s(s({ref:a},d),{},{components:n})):t.createElement(g,s({ref:a},d))}));function g(e,a){var n=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=u;var l={};for(var i in a)hasOwnProperty.call(a,i)&&(l[i]=a[i]);l.originalType=e,l[p]="string"==typeof e?e:o,s[1]=l;for(var c=2;c<r;c++)s[c]=n[c];return t.createElement.apply(null,s)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7204:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>i,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=n(7462),o=(n(7294),n(3905));const r={},s="Patr\xf3n Memento o Patr\xf3n Token",l={unversionedId:"patterns/comportamiento/Memento/Readme",id:"patterns/comportamiento/Memento/Readme",title:"Patr\xf3n Memento o Patr\xf3n Token",description:"Estudiantes:",source:"@site/docs/5.patterns/comportamiento/Memento/Readme.md",sourceDirName:"5.patterns/comportamiento/Memento",slug:"/patterns/comportamiento/Memento/",permalink:"/software-design/docs/patterns/comportamiento/Memento/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/5.patterns/comportamiento/Memento/Readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introducci\xf3n",permalink:"/software-design/docs/patterns/comportamiento/"},next:{title:"**Investigaci\xf3n del patr\xf3n de dise\xf1o Observer**",permalink:"/software-design/docs/patterns/comportamiento/ObserverPattern/"}},i={},c=[{value:"Tabla de Contenidos",id:"tabla-de-contenidos",level:2},{value:"Problema",id:"problema",level:2},{value:"Soluci\xf3n",id:"soluci\xf3n",level:2},{value:"Ejemplo de c\xf3digo",id:"ejemplo-de-c\xf3digo",level:2},{value:"Consecuencias",id:"consecuencias",level:2},{value:"Implementaci\xf3n",id:"implementaci\xf3n",level:2},{value:"Relaci\xf3n con otros patrones",id:"relaci\xf3n-con-otros-patrones",level:2},{value:"Relaci\xf3n con principios de dise\xf1o",id:"relaci\xf3n-con-principios-de-dise\xf1o",level:2},{value:"Referencias",id:"referencias",level:2},{value:"Anexo",id:"anexo",level:2}],d={toc:c},p="wrapper";function m(e){let{components:a,...r}=e;return(0,o.kt)(p,(0,t.Z)({},d,r,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"patr\xf3n-memento-o-patr\xf3n-token"},"Patr\xf3n Memento o Patr\xf3n Token"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Estudiantes"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Julio Rodroguez Salguera C16717"),(0,o.kt)("li",{parentName:"ul"},"Geancarlo Rivera Hern\xe1ndez C06516")),(0,o.kt)("h2",{id:"tabla-de-contenidos"},"Tabla de Contenidos"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#patr%C3%B3n-memento-o-patr%C3%B3n-token"},"Patr\xf3n Memento o Patr\xf3n Token"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#tabla-de-contenidos"},"Tabla de Contenidos")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#problema"},"Problema")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#soluci%C3%B3n"},"Soluci\xf3n")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ejemplo-de-c%C3%B3digo"},"Ejemplo de c\xf3digo")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#consecuencias"},"Consecuencias")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#implementaci%C3%B3n"},"Implementaci\xf3n")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#relaci%C3%B3n-con-otros-patrones"},"Relaci\xf3n con otros patrones")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#relaci%C3%B3n-con-principios-de-dise%C3%B1o"},"Relaci\xf3n con principios de dise\xf1o")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#referencias"},"Referencias")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#anexo"},"Anexo"))))),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"problema"},"Problema"),(0,o.kt)("p",null,"El patr\xf3n Memento es muy \xfatil cuando se necesita preservar el estado de un objeto, componente o sistema sin comprometer su encapsulaci\xf3n. Es decir, el patr\xf3n Memento se utiliza para restaurar un objeto a un estado anterior, lo que resulta muy beneficioso para corregir errores o implementar un historial de versiones. Una caracter\xedstica importante de este patr\xf3n es que protege la encapsulaci\xf3n de los objetos, ya que la interfaz para modificar el estado guardado solo puede ser accedida por la clase que lo cre\xf3, siendo inaccesible y opaca para las dem\xe1s clases."),(0,o.kt)("p",null,'Este patr\xf3n es especialmente \xfatil cuando se necesita recordar y restaurar el estado de un objeto en un momento espec\xedfico. Imaginemos que estamos trabajando en una aplicaci\xf3n y deseamos implementar la funci\xf3n "deshacer". En lugar de guardar m\xfaltiples copias del estado actual, el patr\xf3n Memento permite almacenar solo ciertos estados de un objeto "Originator" en estructuras llamadas "Memento".'),(0,o.kt)("p",null,'Un ejemplo interesante que ilustra el uso del patr\xf3n Memento se encuentra en la plataforma de Correo Institucional de la Universidad de Costa Rica. Al redactar un correo, existe la posibilidad de volver al estado previo al presionar la combinaci\xf3n de teclas "Ctrl + z". Por ejemplo, es posible regresar del texto "Buenas tardes profesor!" (',(0,o.kt)("strong",{parentName:"p"},"Figura 1"),') al texto previo "Buenas tardes" (',(0,o.kt)("strong",{parentName:"p"},"Figura 2"),"), que fue el \xfaltimo estado almacenado gracias al patr\xf3n Memento."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"estadoActual",src:n(8268).Z,width:"1150",height:"686"})),(0,o.kt)("p",null,"FIGURA 1: Estado actual del correo (Captura del Corre Universidad de Costa Rica)"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"estadoAnterior",src:n(1977).Z,width:"1151",height:"686"})),(0,o.kt)("p",null,"FIGURA 2: Estado anterior del correo"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"estadoInicial",src:n(6291).Z,width:"1151",height:"686"})),(0,o.kt)("p",null,"FIGURA 3: Estado inicial del correo"),(0,o.kt)("p",null,'Adem\xe1s, en el sistema de Correo Institucional, no solo es posible regresar al estado anterior al actual, sino que tambi\xe9n se tiene la opci\xf3n de regresar al estado inicial del correo si se contin\xfaa utilizando la acci\xf3n "Ctrl + z" (',(0,o.kt)("strong",{parentName:"p"},"Figura 3"),") de manera consecutiva. Esto permite retroceder y restaurar el texto al punto en el que se comenz\xf3 a redactar el correo."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"soluci\xf3n"},"Soluci\xf3n"),(0,o.kt)("p",null,"El patr\xf3n Memento utiliza y se basa en tres componentes principales para definir e implementar su estructura, que pueden ser observados en el diagrama UML de la ",(0,o.kt)("strong",{parentName:"p"},"Figura 4"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"umlMemento",src:n(4823).Z,width:"501",height:"287"})),(0,o.kt)("p",null,"FIGURA 4: Diagrama UML del patr\xf3n de comportamiento Memento"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Memento"),"\nLa clase Memento es responsable de almacenar la informaci\xf3n del estado en un momento espec\xedfico del componente ",(0,o.kt)("em",{parentName:"p"},"Originator"),", conocido com\xfanmente como ",(0,o.kt)("em",{parentName:"p"},"snapshot"),". Contiene toda la informaci\xf3n necesaria para restaurar versiones anteriores de manera precisa. Estos objetos Memento se guardan en una estructura de datos en el componente ",(0,o.kt)("em",{parentName:"p"},"Caretaker"),". Es importante destacar que el acceso a los datos del Memento se limitan \xfanicamente al componente ",(0,o.kt)("em",{parentName:"p"},"Originator"),", ya que \xe9ste utiliza los datos para recuperar estados anteriores (Haythornwaite, 2002, p. 285)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Originator"),"\nEl Originator es la clase de la cual se toma el ",(0,o.kt)("em",{parentName:"p"},"snapshot")," que se almacena en los objetos ",(0,o.kt)("em",{parentName:"p"},"Memento"),". Es el componente que contiene el estado actual del sistema y utiliza objetos ",(0,o.kt)("em",{parentName:"p"},"Memento")," para recuperar estados anteriores (Haythornwaite, 2002, p. 165). Esta clase interact\xfaa directamente con los objetos ",(0,o.kt)("em",{parentName:"p"},"Memento"),", ya que necesita leer su contenido para restaurar sus datos."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Caretaker"),"\nEl Caretaker es el componente encargado de almacenar los ",(0,o.kt)("em",{parentName:"p"},"snapshots"),", es decir, los objetos ",(0,o.kt)("em",{parentName:"p"},"Memento"),". Tambi\xe9n es responsable de implementar las interfaces que permiten al cliente indicar a la clase ",(0,o.kt)("em",{parentName:"p"},"Originator")," guardar el estado actual o volver a un estado anterior espec\xedfico. Este componente no interact\xfaa directamente con los objetos Memento ni puede acceder a su informaci\xf3n, simplemente los almacena (Haythornwaite, 2002, p. 165)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Interacci\xf3n entre los componentes"),"\nEn el patr\xf3n Memento, los componentes interact\xfaan de la siguiente manera: el cliente por medio de la interfaz Caretaker solicita al Originator guardar su estado actual, por lo que el Originator crea un nuevo objeto Memento y se lo devuelve al Caretaker para que lo almacene. Cuando el cliente solicita volver a un estado anterior, el Caretaker proporciona al Originator el estado deseado que est\xe1 almacenado en el Memento. El Originator toma el ",(0,o.kt)("em",{parentName:"p"},"snapshot")," del estado y lo aplica, volviendo al estado previo. Esto permite ocultar la implementaci\xf3n y los datos del Memento y del Originator a clases externas."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"ejemplo-de-c\xf3digo"},"Ejemplo de c\xf3digo"),(0,o.kt)("p",null,'Si desea comprender con mayor profundad el funcionamiento del patr\xf3n Memento y c\xf3mo implementarlo en un sistema, puede observar el c\xf3digo de ejemplo que se encuentra en la carpeta "src", la cu\xe1l contiene un ejemplo de guardado de estados del Correo Institucional de la Universidad de Costa Rica utilizando el patr\xf3n Memento.\nPuede visitar el main del este c\xf3digo en este ',(0,o.kt)("a",{target:"_blank",href:n(3705).Z},"link"),"."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"consecuencias"},"Consecuencias"),(0,o.kt)("p",null,"Seg\xfan lo expuesto por Haythornwaite (2002), el patr\xf3n Memento conlleva las siguientes consecuencias:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Preservaci\xf3n de la encapsulaci\xf3n:")," El uso de la clase Memento garantiza que solo el Originator tenga acceso a la informaci\xf3n que debe manejar, al mismo tiempo que se almacena fuera de \xe9l. Esto protege a otros objetos de interactuar con la complejidad interna del Originator y mantiene los l\xedmites de la encapsulaci\xf3n.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Simplificaci\xf3n del Originator:")," En comparaci\xf3n con otros dise\xf1os que tambi\xe9n preservan la encapsulaci\xf3n, el patr\xf3n Memento simplifica al Originator. En lugar de que el Originator tenga que mantener las versiones del estado interno solicitadas por los clientes, permite que los clientes administren el estado que necesitan por medio del Caretaker. Esto evita la carga de almacenamiento y gesti\xf3n en el Originator y elimina la necesidad de que los clientes notifiquen al Originator cuando han terminado.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Posibles costos asociados con el uso de Mementos:")," El uso de Mementos puede generar una sobrecarga considerable en ciertos casos. Por ejemplo, si el Originator necesita copiar grandes cantidades de informaci\xf3n para almacenar en el Memento, o si los clientes crean y devuelven Mementos con mucha frecuencia al Originator. Por lo tanto, en situaciones donde la encapsulaci\xf3n y la restauraci\xf3n del estado del Originator representan un costo significativo, el patr\xf3n Memento puede no ser apropiado. Es importante considerar la escalabilidad y los costos asociados durante la implementaci\xf3n.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Definici\xf3n de interfaces:")," En algunos lenguajes de programaci\xf3n, puede resultar complicado garantizar que solo el Originator pueda acceder al estado del Memento. Esto requiere establecer interfaces precisas y rigurosas para manejar adecuadamente esta situaci\xf3n, lo que puede aumentar la complejidad del patr\xf3n.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Costos ocultos en la gesti\xf3n de Mementos:")," El Caretaker es responsable de eliminar los Mementos que maneja, pero no sabe cu\xe1nto estado contiene cada Memento. Dado que el estado representa la informaci\xf3n relevante necesaria para restaurar el estado de un objeto a un punto anterior en el tiempo, un Caretaker aparentemente ligero puede generar costos significativos de almacenamiento al respaldar los Mementos. Es fundamental tener en cuenta este aspecto al gestionar los Mementos."))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"implementaci\xf3n"},"Implementaci\xf3n"),(0,o.kt)("p",null,"Seg\xfan Haythornwaite (2002), al implementar el patr\xf3n Memento, se deben tener en cuenta los siguientes aspectos principales:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Soporte de lenguaje:"),' Los Mementos tienen dos interfaces: una amplia para los Originators y una estrecha para otros objetos. Idealmente, el lenguaje de implementaci\xf3n deber\xeda permitir dos niveles de protecci\xf3n est\xe1tica. Algunos lenguajes pueden lograr esto utilizando funciones "friend", aunque en otros casos puede resultar m\xe1s r\xedgido. La elecci\xf3n del lenguaje de programaci\xf3n puede ser un aspecto importante a considerar debido a los niveles de protecci\xf3n necesarios en las interfaces de los Mementos.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Cambios incrementales:")," Cuando se utilizan Mementos en una secuencia predecible por el Originator, es posible almacenar solo los cambios incrementales en el estado interno del objeto Originator. Por ejemplo, en una lista de historial de comandos reversibles, los Mementos permiten restaurar los comandos a su estado exacto cuando se deshacen. En lugar de almacenar el estado completo de cada objeto afectado, los Mementos solo registran los cambios realizados por los comandos. Al permitir que los Mementos guarden solo los cambios incrementales en lugar del estado completo de cada objeto afectado, se puede reducir la cantidad de informaci\xf3n almacenada y optimizar el uso de memoria. Esto es especialmente relevante cuando el estado del objeto es grande o cuando se manejan secuencias de cambios en el tiempo, como en el ejemplo mencionado de una lista de historial de comandos. Adem\xe1s, esta capacidad de almacenar cambios incrementales tambi\xe9n puede tener un impacto positivo en el rendimiento al deshacer o rehacer acciones. Al acceder solo a los cambios necesarios en lugar de reconstruir todo el estado, se pueden lograr tiempos de respuesta m\xe1s r\xe1pidos y una experiencia de usuario m\xe1s fluida.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Definir adecuadamente las responsabilidades del Caretaker:")," Es importante establecer claramente las responsabilidades del Caretaker en cuanto a la gesti\xf3n y almacenamiento de los Mementos. El Caretaker es el encargado de eliminar los Mementos cuando ya no son necesarios, pero debe tener en cuenta que no conoce la cantidad de estado que contiene cada Memento. Esto implica que el Caretaker puede generar costos de almacenamiento significativos al respaldar los Mementos. Por lo tanto, es esencial definir adecuadamente las responsabilidades del Caretaker para asegurar una gesti\xf3n eficiente de los Mementos.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Considerar granularidad para almacenar cambios incrementales:")," Al almacenar cambios incrementales en lugar del estado completo del objeto afectado, se debe considerar la granularidad de los cambios. Es importante determinar qu\xe9 cambios son relevantes y necesarios de almacenar en los Mementos para asegurar una restauraci\xf3n adecuada del estado. Una granularidad inadecuada puede afectar negativamente la funcionalidad del patr\xf3n.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Considerar el impacto y rendimiento al guardar estados de objetos grandes o complejos:")," Cuando se trabajan con objetos grandes o complejos, guardar y restaurar el estado puede tener un impacto significativo en el rendimiento. Es importante evaluar cuidadosamente el costo asociado con el almacenamiento y la restauraci\xf3n de estados en estas situaciones. En algunos casos, puede ser m\xe1s eficiente almacenar solo los cambios incrementales, utilizar t\xe9cnicas de optimizaci\xf3n espec\xedficas o simplemente evitar el uso del patr\xf3n.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Combinar con otros patrones:")," El patr\xf3n Memento se puede combinar con otros patrones de dise\xf1o, como el Command o el Observer, para ofrecer una funcionalidad m\xe1s completa y flexible. Estas combinaciones pueden mejorar la modularidad, la separaci\xf3n de preocupaciones y la capacidad de extensi\xf3n del sistema. Al considerar la implementaci\xf3n del patr\xf3n Memento, es recomendable explorar c\xf3mo se puede integrar con otros patrones relevantes para obtener mejores resultados en el dise\xf1o global del sistema."))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"relaci\xf3n-con-otros-patrones"},"Relaci\xf3n con otros patrones"),(0,o.kt)("p",null,"El patr\xf3n Memento se relaciona con otros patrones de dise\xf1o debido a su naturaleza y funcionalidad:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Command:")," El patr\xf3n Command y el patr\xf3n Memento se complementan entre s\xed. Mientras que el patr\xf3n Memento se utiliza para capturar y restaurar el estado de un objeto, el patr\xf3n Command se utiliza para encapsular una solicitud como un objeto, permitiendo as\xed deshacer y rehacer acciones. En conjunto, estos patrones pueden proporcionar una forma poderosa de implementar funcionalidades como deshacer y rehacer en una aplicaci\xf3n.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Iterator:")," El patr\xf3n Memento y el patr\xf3n Iterator pueden combinarse para facilitar la navegaci\xf3n y el acceso a los elementos de una estructura de datos. El patr\xf3n Memento se puede utilizar para almacenar snapshots del estado de una estructura de datos en diferentes puntos, mientras que el patr\xf3n Iterator proporciona un mecanismo para recorrer y acceder a esos elementos de manera secuencial. Esto puede mejorar la manipulaci\xf3n y gesti\xf3n de estructuras de datos complejas.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Editor:")," Estos patrones se relacionan en el contexto de la edici\xf3n y gesti\xf3n de documentos. El patr\xf3n Memento captura y almacenar el estado de un documento en diferentes momentos, mientras que el patr\xf3n Editor proporciona interfaces de edici\xf3n y coordina las acciones relacionadas con la manipulaci\xf3n del documento. De esta manera ambos patrones brindan una forma eficiente de gestionar la edici\xf3n y el historial de cambios en un editor de documentos.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"State:")," El patr\xf3n State se utiliza para representar diferentes estados de un objeto y controlar su comportamiento en funci\xf3n de su estado actual. En conjunto, estos patrones pueden proporcionar una forma flexible y eficiente de gestionar el estado y el comportamiento de un objeto en un sistema."))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"relaci\xf3n-con-principios-de-dise\xf1o"},"Relaci\xf3n con principios de dise\xf1o"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Principio de Responsabilidad \xdanica:")," El patr\xf3n separa la responsabilidad de almacenar los estados de la clase Originator y se la delega a la clase Memento, que es responsable \xfanicamente de encapsular el estado y no debe tener ninguna l\xf3gica adicional. Gracias a esto se sigue este principios de SOLID, pues se evita que la clase Originator tenga m\xe1s responsabilidades de las necesarias.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Programaci\xf3n Orientada a Objetos:")," Este patr\xf3n busca mantener la encapsulaci\xf3n de los datos de los objetos Memento, con el fin de evitar que clases externas puedan ingresar a la informaci\xf3n del Memento. Este objeto puede ser almacenado en otras clases pero su informaci\xf3n solo puede ser ingresada por la clase Originator.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"KISS:")," El patr\xf3n Memento no vuelve el sistema m\xe1s simple por si mismo, pero una correcta implementaci\xf3n puede crear una l\xf3gica y c\xf3digo m\xe1s simple y sencilla de comprender.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"DRY:")," El patr\xf3n Memento, al igual que el principio KISS, no aborda directamente la duplicidad de c\xf3digo, pero su implementaci\xf3n adecuada puede prevenir la duplicaci\xf3n en la gesti\xf3n de estados al centralizar la interfaz de guardado y recuperaci\xf3n de estados del sistema. Esto permite una gesti\xf3n eficiente y coherente del estado sin repetir l\xf3gica en m\xfaltiples partes del c\xf3digo."))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"referencias"},"Referencias"),(0,o.kt)("p",null,"Haythornwaite, C. (2002). Gamma, E., Helm, R., Johnson, R. & Vlissides, J. Design Patterns: Elements of Reusable Object Oriented Software. New York: Addison-Wesley, 1995. ADDISON-WESLEY."),(0,o.kt)("p",null,"Savoir, L.A. (2007) Pattern design. Beverly, MA: Rockport Publishers."),(0,o.kt)("p",null,"Smith, J.M. (2012) Elemental Design Patterns. Upper Saddle River, NJ: Addison-Wesley."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"anexo"},"Anexo"),(0,o.kt)("p",null,"Si desea ver la presentaci\xf3n asociada a este patr\xf3n vea: ",(0,o.kt)("a",{target:"_blank",href:n(6468).Z},"Presentaci\xf3n Patr\xf3n Memento")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#tabla-de-contenidos"},"Volver al \xedndice")))}m.isMDXComponent=!0},6468:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/files/Patr\xf3nMementoPresentaci\xf3n-ce94ed207e9ac8ba7c9ed7461e4a3f97.pdf"},3705:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/files/Main-6f12002e58d0137d49801af4f28b06b4.java"},4823:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/images/DiagramaUMLMemento-9f374f2e3180991424c75d361fbb9526.svg"},8268:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/images/estadoActualCorreo-6be81e1c25a143471c85b0f1157ff2fa.svg"},1977:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/images/estadoAnteriorCorreo-6585369d67e6de70fe14e050b257ec66.svg"},6291:(e,a,n)=>{n.d(a,{Z:()=>t});const t=n.p+"assets/images/estadoInicialCorreo-ed8d5d511f6e7ebd59f969dc4ade0048.svg"}}]);