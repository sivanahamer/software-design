"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8841],{3905:(e,a,n)=>{n.d(a,{Zo:()=>c,kt:()=>b});var t=n(7294);function s(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){s(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function r(e,a){if(null==e)return{};var n,t,s=function(e,a){if(null==e)return{};var n,t,s={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(s[n]=e[n]);return s}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=t.createContext({}),d=function(e){var a=t.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},c=function(e){var a=d(e.components);return t.createElement(l.Provider,{value:a},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef((function(e,a){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=d(n),m=s,b=p["".concat(l,".").concat(m)]||p[m]||u[m]||i;return n?t.createElement(b,o(o({ref:a},c),{},{components:n})):t.createElement(b,o({ref:a},c))}));function b(e,a){var n=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var i=n.length,o=new Array(i);o[0]=m;var r={};for(var l in a)hasOwnProperty.call(a,l)&&(r[l]=a[l]);r.originalType=e,r[p]="string"==typeof e?e:s,o[1]=r;for(var d=2;d<i;d++)o[d]=n[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2572:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=n(7462),s=(n(7294),n(3905));const i={},o="Chain Of Responsibility",r={unversionedId:"patterns/comportamiento/ChainOfResponsability/README",id:"patterns/comportamiento/ChainOfResponsability/README",title:"Chain Of Responsibility",description:"Nombres",source:"@site/docs/5.patterns/comportamiento/ChainOfResponsability/README.md",sourceDirName:"5.patterns/comportamiento/ChainOfResponsability",slug:"/patterns/comportamiento/ChainOfResponsability/",permalink:"/software-design/docs/patterns/comportamiento/ChainOfResponsability/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/5.patterns/comportamiento/ChainOfResponsability/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introducci\xf3n",permalink:"/software-design/docs/patterns/comportamiento/"},next:{title:"Patr\xf3n Memento o Patr\xf3n Token",permalink:"/software-design/docs/patterns/comportamiento/Memento/"}},l={},d=[{value:"Nombres",id:"nombres",level:2},{value:"PROBLEMA",id:"problema",level:2},{value:"SOLUCI\xd3N",id:"soluci\xf3n",level:2},{value:"Estructura",id:"estructura",level:2},{value:"Ejemplo con la UCR: Sistema de Solicitudes",id:"ejemplo-con-la-ucr-sistema-de-solicitudes",level:2},{value:"COLABORACIONES",id:"colaboraciones",level:2},{value:"Implementaci\xf3n",id:"implementaci\xf3n",level:2},{value:"Dos formas de implementar la cadena de sucesi\xf3n",id:"dos-formas-de-implementar-la-cadena-de-sucesi\xf3n",level:3},{value:"Conectar sucesores",id:"conectar-sucesores",level:3},{value:"Representaci\xf3n de requests",id:"representaci\xf3n-de-requests",level:3},{value:"Ejemplo en c\xf3digo",id:"ejemplo-en-c\xf3digo",level:2},{value:"Consecuencias",id:"consecuencias",level:2},{value:"Malas",id:"malas",level:3},{value:"Buenas",id:"buenas",level:3},{value:"Relaci\xf3n con otros patrones",id:"relaci\xf3n-con-otros-patrones",level:2},{value:"Composite",id:"composite",level:3},{value:"Principios SOLID",id:"principios-solid",level:2},{value:"Principios de Dise\xf1o asociados",id:"principios-de-dise\xf1o-asociados",level:2},{value:"Bibliograf\xeda",id:"bibliograf\xeda",level:2}],c={toc:d},p="wrapper";function u(e){let{components:a,...n}=e;return(0,s.kt)(p,(0,t.Z)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"chain-of-responsibility"},"Chain Of Responsibility"),(0,s.kt)("h2",{id:"nombres"},"Nombres"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"COR")),(0,s.kt)("h2",{id:"problema"},"PROBLEMA"),(0,s.kt)("p",null,"Supongamos que tenemos una solicitud. Esa solicitud debe de pasar por diferentes niveles jer\xe1rjicos para establecer\nqui\xe9n o qui\xe9nes pueden manejarla. Una soluci\xf3n a este problema es la utilizaci\xf3n del patr\xf3n Chain of Responsibility."),(0,s.kt)("p",null,"Tambi\xe9n, imaginemos que usted tiene un sistema de solicitudes, el cual puede ser manejado por diferentes Handlers."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/51610aee-23c5-48b3-a564-2a9d82748635",alt:"Sistema simple de manejadores"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 1. Elaboraci\xf3n propia")),(0,s.kt)("p",null,"Sin embargo su sistema crece demasiado y ocupa una soluci\xf3n que le provea flexibilidad. Es decir, que sea simple a\xf1adir\nmanejadores o remover. El patr\xf3n chain of responsibility es una excelente opci\xf3n."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/887d6e73-22b2-4fc5-8c91-716834e2c1fa",alt:"Sistema complejo de solicitudes"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 2. Elaboraci\xf3n propia")),(0,s.kt)("h2",{id:"soluci\xf3n"},"SOLUCI\xd3N"),(0,s.kt)("p",null,"Para dicho sistema, tal y como se mencion\xf3, lo ideal es establecer una cadena de responsabilidad, en el cual, la solicitud se va pasando de manejador en manejador, hasta que\nuno o varios, manejen la solicitud."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/98c8d533-c05d-4db1-b512-0fd11004663a",alt:"Manejadores pas\xe1ndose la solicitud"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 3. Imagen tomada de Refactoring Guru")),(0,s.kt)("p",null,"B\xe1sicamente se establece una cadena de objetos encadenados. Cada objeto tiene la opci\xf3n de manejar la solicitud o pasarla al siguiente objeto en la cadena. Esto reduce el acoplamiento, ya que el remitente solo necesita enviar la solicitud al primer objeto de la cadena, y cada objeto decide si puede manejarla o pasarla al siguiente objeto. Esto permite una mejor mantenibilidad y flexibilidad del c\xf3digo, ya que los objetos de manejo pueden agregarse o eliminarse sin afectar al remitente."),(0,s.kt)("h2",{id:"estructura"},"Estructura"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/43435f3f-72bd-40e4-9bf6-c85910cb843b",alt:"Estrucutra de COR"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 4. Imagen tomada de Gamma et al")),(0,s.kt)("p",null,"En s\xed, la estrucutra esta formada por los siguientes elementos:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Una interfaz llamada Handler, la cual se utiliza como base para los concreteHandlers, establece el m\xe9todo HandleRequest() y un apuntador hacia su sucesor de tipo Handler."),(0,s.kt)("li",{parentName:"ul"},"ConcreteHandlers, son los manjadores concretos, implementan la interfaz Handler."),(0,s.kt)("li",{parentName:"ul"},"Cliente, es quien interact\xfaa con la cadena enviando la solicitud.")),(0,s.kt)("h2",{id:"ejemplo-con-la-ucr-sistema-de-solicitudes"},"Ejemplo con la UCR: Sistema de Solicitudes"),(0,s.kt)("p",null,"Imagine que la universidad tiene un sistema de solicitudes, la cual reparte las solicitudes entre todos sus \xf3rganos (Registro, Oficina de Becas,\nOficina de Bienestar y Salud, ...)"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/70e4e205-e673-465c-ba56-94d63bbd3c9e",alt:"Imagen del ejemplo de la UCR. Imagen 1"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 5. Elaboraci\xf3n propia")),(0,s.kt)("p",null,"Sin embargo, cada vez que se cree un \xf3rgano en la instituci\xf3n, se deber\xe1 integrar en el sistema o bien, si uno cierra se deber\xe1 de eliminar, mismamente una solicitud\npuede ser tratada por varios \xf3rganos a la vez. Por lo tanto una v\xeda sencilla de manejar este sistema es por medio de la implementaci\xf3n del patr\xf3n: Chain of Responsibility."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/53bfbf2a-d5aa-441f-9e5d-ef2e521dfe12",alt:"Imagen del ejemplo de la UCR. Imagen 2"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 6. Elaboraci\xf3n propia")),(0,s.kt)("p",null,"El sistema principal ser\xeda el cliente, y cada uno de los \xf3rganos de la UCR, ser\xeda un concreteHandler."),(0,s.kt)("h2",{id:"colaboraciones"},"COLABORACIONES"),(0,s.kt)("p",null,"El sistema de colaboraci\xf3n es muy sencillo. El cliente env\xeda la solicitud y cada concrete Handler propaga la solicitud entre los sucesores."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/82900350/da0c671c-8b71-4f8d-abe3-78fb55c84fb5",alt:"Colaboraciones en COR"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Figura 6. Elaboraci\xf3n propia")),(0,s.kt)("h2",{id:"implementaci\xf3n"},"Implementaci\xf3n"),(0,s.kt)("p",null,"A la hora de implementar una aplicaci\xf3n con un patr\xf3n de dise\xf1o chain of responsibility, se deben tomar en cuenta las siguientes consideraciones:"),(0,s.kt)("h3",{id:"dos-formas-de-implementar-la-cadena-de-sucesi\xf3n"},"Dos formas de implementar la cadena de sucesi\xf3n"),(0,s.kt)("p",null,"Hay dos principales variaciones a la hora de implementar la cadena de sucesi\xf3n:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Crear nuevos links: es b\xe1sicamente cuando no existe ning\xfan tipo de relaci\xf3n entre los objetos de la cadena que se desea."),(0,s.kt)("li",{parentName:"ol"},"Usar links existentes: a veces, ya existe una jerarqu\xeda que define relaciones entre los objetos que se quieren relacionar, por lo que se pueden reutilizar estos links. Un ejemplo de esto son jerarqu\xedas de clases donde cada instancia tiene una propiedad parent, y yo puedo usar ese parent como referencia al sucesor.")),(0,s.kt)("h3",{id:"conectar-sucesores"},"Conectar sucesores"),(0,s.kt)("p",null,"Si no existe una relaci\xf3n entre clases que me permita crear una cadena, yo debo crearla manualmente. Esto significa que ahora el Handler no solo define una interfaz para los requests, sino que tambi\xe9n tiene un sucesor. El tener este sucesor como atributo le permite tener una implementaci\xf3n default para el m\xe9todo de Handle. Entonces, si un ConcreteHandler no est\xe1 interesado en manejar el request, simplemente no sobreescribe el m\xe9todo Handle, porque por default ya llama al sucesor a manejarlo."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/04526e2a-5f73-41d2-83e9-9cbeb7c08eb5",alt:"Imagen"})," "),(0,s.kt)("h3",{id:"representaci\xf3n-de-requests"},"Representaci\xf3n de requests"),(0,s.kt)("p",null,"Hay dos formas de manejar los requests a la hora de utilizar el patr\xf3n the chain of responsibility. La primera es hacer un m\xe9todo Handle para cada request posible. Esto es conveniente y muy seguro, sin embargo, es poco flexible, pues habr\xeda que crear un m\xe9todo por cada request."),(0,s.kt)("p",null,"La otra alternativa es m\xe1s flexible pero m\xe1s insegura. Se trata de crear un \xfanico m\xe9todo Handle llamado HandleRequest. A este m\xe9todo se le pasa el tipo de request como par\xe1metro (ya sea como un entero, string, etc). El \xfanico requisito es que tanto el receptor como el emisor est\xe9n de acuerdo con el formato de request. Las desventajas son que ahora se necesita una l\xf3gica de ifs y no se puede asegurar que el par\xe1metro que se pase sea de un tipo de datos correcto."),(0,s.kt)("p",null,"Una soluci\xf3n a este problema del tipado del par\xe1metro es crear una clase abstracta Request, que va a ser heredada por los diferentes tipos de requests. Finalmente, se pasa un puntero de un objeto Request al m\xe9todo HandleRequest y este lo desempaca dependiendo del tipo de request que sea (el tipo de request se obtiene al agregar un m\xe9todo a la clase Request que retorne el tipo)."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/4774ec8a-b496-4805-922a-2eb308bdea3f",alt:"Imagen"})," "),(0,s.kt)("h2",{id:"ejemplo-en-c\xf3digo"},"Ejemplo en c\xf3digo"),(0,s.kt)("p",null,"Supongamos que se quiere programar un ATM. Este por dentro tiene la capacidad de dispensar 3 tipos de billetes: 50$, 20$ y 10$. Para cada tipo de billete hay un dispensador diferente. Entonces, por dentro del ATM se tiene un dispensador de 50$, uno de 20$ y uno de 10$. Por convenci\xf3n, el ATM quiere dispensar la menor cantidad de billetes posibles, o sea, entre m\xe1s grande el billete, mejor. Para eso, el sistema deber\xeda primero dispensar billetes de 50$, luego de 20$ y finalmente de 10$. Esto empieza a sonar como una cadena de responsabilidades. Lo que se quiere entonces es que el primer dispensador siempre sea el de 50$. Y conforme sea necesario, vaya bajando en la cadena hasta que termine en los billetes m\xe1s peque\xf1os. Se tiene entonces el siguiente c\xf3digo:"),(0,s.kt)("p",null,"Se crea una clase wrapper para el monto solicitado:"),(0,s.kt)("p",null,"Aqu\xed tienes las l\xedneas corregidas con el formato correcto de Markdown:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/c9042efe-df9b-4e73-bcf2-0578ef8c819f",alt:"Imagen"})),(0,s.kt)("p",null,"Ahora, se crea la clase que va a servir como Handler y cuyos hijos ser\xe1n los Handlers concretos. Esta va a tener el m\xe9todo para definir su sucesor y el m\xe9todo para procesar el request."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/6da5a4f1-49fd-422f-92ef-7b5df5268940",alt:"image"})),(0,s.kt)("p",null,"Ahora se realizan las 3 clases de ConcreteHandlers, que corresponden a los 3 dispensadores. Cada una sobreescribe los dos m\xe9todos anteriores:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/99583905-c949-4b7e-a4f9-b60fee1413f8",alt:"image"})),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/177a4950-9c44-44ff-8617-0ae0eed57252",alt:"image"})),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/706f9400-aeef-40bf-aa54-d8c58d8816f6",alt:"image"})),(0,s.kt)("p",null,"Y finalmente, se crea la cadena y se configura el orden de la misma:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/sivanahamer/software-design/assets/79823004/95c23d17-ec84-49bb-8974-58178f2490e6",alt:"image"})),(0,s.kt)("h2",{id:"consecuencias"},"Consecuencias"),(0,s.kt)("h3",{id:"malas"},"Malas"),(0,s.kt)("p",null,"El recibimiento de los requests no est\xe1 garantizado: Como no hay un receptor expl\xedcito, no hay garant\xeda de que un request vaya a ser manejado. Puede ser que se caiga al final de la cadena y nunca fue manejado por nadie. Esto tambi\xe9n puede pasar si no se configura bien la cadena."),(0,s.kt)("h3",{id:"buenas"},"Buenas"),(0,s.kt)("p",null,"Menos acoplamiento: Este patr\xf3n libera al objeto de tener que saber a qui\xe9n le manda el request, c\xf3mo funciona la cadena de responsabilidades, o c\xf3mo est\xe1 estructurada. Ning\xfan objeto sabe de la existencia del otro, solo sabe que si \xe9l no puede manejar un request, el sucesor puede que s\xed."),(0,s.kt)("p",null,"Flexibilidad al asignar responsabilidad a los objetos: El orden de responsabilidades es muy flexible, tanto que se puede alterar en tiempo de ejecuci\xf3n. Y las responsabilidades se pueden distribuir entre objetos muy f\xe1cilmente."),(0,s.kt)("h2",{id:"relaci\xf3n-con-otros-patrones"},"Relaci\xf3n con otros patrones"),(0,s.kt)("h3",{id:"composite"},"Composite"),(0,s.kt)("p",null,"En Composite, el parent de un componente puede actuar como su sucesor, al igual que en ciertos casos con Chain of Responsibility."),(0,s.kt)("h2",{id:"principios-solid"},"Principios SOLID"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Principio"),(0,s.kt)("th",{parentName:"tr",align:null},"Descripci\xf3n"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Single Responsibility"),(0,s.kt)("td",{parentName:"tr",align:null},"Cada handler en la cadena tiene una \xfanica responsabilidad, que es manejar un tipo espec\xedfico de mensaje.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Open/Close Principle"),(0,s.kt)("td",{parentName:"tr",align:null},"El patr\xf3n permite extender el comportamiento de la cadena agregando nuevos handlers sin modificar los existentes.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Liskov\u2019s Substitution Principle"),(0,s.kt)("td",{parentName:"tr",align:null},"Los handlers pueden ser sustituidos por subclases o implementaciones concretas sin alterar el funcionamiento del patr\xf3n.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Dependency Inversion"),(0,s.kt)("td",{parentName:"tr",align:null},"Permite que los clientes dependan de abstracciones (interfaz de handler) en lugar de depender de implementaciones concretas.")))),(0,s.kt)("h2",{id:"principios-de-dise\xf1o-asociados"},"Principios de Dise\xf1o asociados"),(0,s.kt)("p",null,"El patr\xf3n de Chain of Responsibility (COR) se relaciona con los siguientes patrones de dise\xf1o de software:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"KISS")," (Keep It Simple, Stupid): COR permite mantener la simplicidad al evitar acoplamientos innecesarios entre el remitente de una solicitud y los objetos que pueden manejarla, lo que facilita la comprensi\xf3n y el mantenimiento del c\xf3digo.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"OOP")," (Object-Oriented Programming): COR se basa en los principios de la programaci\xf3n orientada a objetos, como la encapsulaci\xf3n y la abstracci\xf3n, al separar el procesamiento de una solicitud en objetos independientes y permitir que se agreguen o modifiquen.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"DRY")," (Don't Repeat Yourself): COR promueve la reutilizaci\xf3n del c\xf3digo al permitir que m\xfaltiples objetos en la cadena manejen diferentes aspectos de una solicitud sin duplicar la l\xf3gica en cada uno de ellos, evitando as\xed la repetici\xf3n y mejorando la mantenibilidad."))),(0,s.kt)("h2",{id:"bibliograf\xeda"},"Bibliograf\xeda"),(0,s.kt)("p",null,"Gamma, Erich et.al. \u201cDesign Patterns\u201d. Addison-Wesley, 1995."),(0,s.kt)("p",null,"Refactoring.Guru. (2023). Chain of Responsibility. Refactoring.Guru."))}u.isMDXComponent=!0}}]);